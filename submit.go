package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/rs/zerolog/log"
)

func submit(files []string) {
	for _, file := range files {
		var problem Problem
		err := readProblem(&problem, file)
		if err != nil {
			log.Err(err).Msg("Failed to read problem")
			continue
		}
		if problem.Solution.TypedCode == "" {
			log.Error().Msg("No solution to submit")
			continue
		}
		if problem.Submission.CheckResponse.Finished {
			log.Info().Msg("Already submitted")
			continue
		}
		submission, err := submitAndCheckSolution(problem.Question, problem.Solution)
		if err != nil {
			log.Err(err).Msg("Failed to submit or check the solution")
			continue
		}
		log.Info().Msgf("Submission result: %s", submission.CheckResponse.StatusMsg)
		problem.Submission = *submission
		err = saveProblemInto(problem, file)
		if err != nil {
			log.Err(err).Msg("Failed to save the submission")
			continue
		}
	}
}

func submitAndCheckSolution(q Question, s Solution) (*Submission, error) {
	subReq := SubmitRequest{
		Lang:       s.Lang,
		QuestionId: q.Data.Question.Id,
		TypedCode:  codeToSubmit(s),
	}

	url := "https://leetcode.com/problems/" + q.Data.Question.TitleSlug + "/submit/"
	submissionId, err := submitCode(url, subReq)
	if err != nil {
		return nil, err
	}
	url = fmt.Sprintf("https://leetcode.com/submissions/detail/%d/check/", submissionId)

	checkResponse, err := checkStatus(url, submissionId, 30*time.Second)
	if err != nil {
		return nil, err
	}

	return &Submission{
		SubmitRequest: subReq,
		SubmissionId:  submissionId,
		CheckResponse: *checkResponse,
	}, nil
}

func submitCode(url string, subReq SubmitRequest) (uint64, error) {
	var reqBody bytes.Buffer
	// use encoder, not standard json.Marshal() because we don't need to escape "<", ">" etc. in the source code
	encoder := json.NewEncoder(&reqBody)
	encoder.SetEscapeHTML(false)
	err := encoder.Encode(subReq)
	if err != nil {
		return 0, fmt.Errorf("failed marshalling GraphQL: %w", err)
	}
	log.Trace().Msgf("Submission request body:\n%s", reqBody.String())
	var respBody []byte
	err = expBackoff(30 * time.Second, func() (bool, error) {
		var code int
		respBody, code, err = makeAuthorizedHttpRequest("POST", url, &reqBody)
		if code == http.StatusTooManyRequests {
			return false, nil
		}
		if err != nil {
			return false, err
		}
		log.Debug().Msgf("Submission response body:\n%s", string(respBody))
		return true, nil
	})
	if err != nil {
		return 0, err
	}

	var respStruct map[string]uint64
	err = json.Unmarshal(respBody, &respStruct)
	if err != nil {
		return 0, fmt.Errorf("failed unmarshalling submission response: %w", err)
	}
	submissionId := respStruct["submission_id"]
	if submissionId <= 0 {
		return 0, fmt.Errorf("invalid submission id")
	}
	log.Debug().Msgf("Got submission_id %d", submissionId)

	return submissionId, nil
}

func checkStatus(url string, submissionId uint64, maxWaitTime time.Duration) (*CheckResponse, error) {
	var checkResp CheckResponse
	err := expBackoff(maxWaitTime, func() (bool, error) {
		respBody, code, err := makeAuthorizedHttpRequest("GET", url, bytes.NewReader([]byte{}))
		if code == http.StatusTooManyRequests {
			return false, nil
		}
		if err != nil {
			return false, err
		}
		log.Trace().Msgf("Check response body:\n%s", string(respBody))

		err = json.Unmarshal(respBody, &checkResp)
		if err != nil {
			return false, fmt.Errorf("failed unmarshalling check response: %w", err)
		}
		if checkResp.Finished {
			return true, nil
		}
		return false, nil
	})
	if err != nil {
		return nil, err
	}
	return &checkResp, nil
}

func codeToSubmit(s Solution) string {
	return "# leetgptsolver submission\n" +
		fmt.Sprintf("# solution generated by model %s at %s \n", s.Model, s.SolvedAt) +
		s.TypedCode
}
